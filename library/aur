#!/usr/bin/python

<<<<<<< HEAD
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from ansible.module_utils.basic import *
from ansible.module_utils.urls import open_url
import json
import tarfile
import os
import os.path
import tempfile


DOCUMENTATION = '''
---
module: aur
short_description: Manage packages from the AUR
description:
    - Manage packages from the Arch User Repository (AUR)
author:
    - Kewl <xrjy@nygb.rh.bet(rot13)>
options:
    name:
        description:
            - Name or list of names of the package(s) to install or upgrade.

    upgrade:
        description:
            - Whether or not to upgrade whole system.
        type: bool
        default: no

    use:
        description:
            - The helper to use, 'auto' uses the first known helper found and makepkg as a fallback.
        default: auto
        choices: [ auto, aurman, pacaur, trizen, pikaur, yay, makepkg ]

    skip_installed:
        description:
            - Skip operations if the package is present.
        type: bool
        default: no

    skip_pgp_check:
        description:
            - Skip verification of PGP signatures.
              This is useful when installing packages on a host without GnuPG (properly) configured.
              Only valid with makepkg.
        type: bool
        default: no

    aur_only:
        description:
            - Limit operation to the AUR. Compatible with yay, aurman, pacaur and trizen.
notes:
  - When used with a `loop:` each package will be processed individually,
    it is much more efficient to pass the list directly to the `name` option.
'''

RETURN = '''
msg:
    description: action that has been taken
helper:
    the helper that was actually used
'''

EXAMPLES = '''
- name: Install trizen using makepkg, skip if trizen is already installed
  aur: name=trizen use=makepkg skip_installed=true
  become: yes
  become_user: aur_builder
'''


def_lang = ['env', 'LC_ALL=C']

use_cmd = {
    'aurman': ['aurman', '-S', '--noconfirm', '--noedit', '--needed', '--skip_news', '--pgp_fetch', '--skip_new_locations'],
    'yay': ['yay', '-S', '--noconfirm', '--needed'],
    'pacaur': ['pacaur', '-S', '--noconfirm', '--noedit', '--needed'],
    'trizen': ['trizen', '-S', '--noconfirm', '--noedit', '--needed'],
    'pikaur': ['pikaur', '-S', '--noconfirm', '--noedit', '--needed'],
    'makepkg': ['makepkg', '--syncdeps', '--install', '--noconfirm', '--needed']
}

has_aur_option = ['yay', 'aurman', 'pacaur', 'trizen']


def package_installed(module, package):
    """
    Determine if the package is already installed
    """
    rc, _, _ = module.run_command(['pacman', '-Q', package], check_rc=False)
    return rc == 0


def check_packages(module, packages):
    """
    Inform the user what would change if the module were run
    """
    would_be_changed = []

    for package in packages:
        installed = package_installed(module, package)
        if not installed:
            would_be_changed.append(package)

    if would_be_changed:
        status = True
        if (len(packages) > 1):
            message = '%s package(s) would be installed' % str(len(would_be_changed))
        else:
            message = 'package would be installed'
    else:
        status = False
        if (len(packages) > 1):
            message = 'all packages are already installed'
        else:
            message = 'package is already installed'
    module.exit_json(changed=status, msg=message)


def install_with_makepkg(module, package):
    """
    Install the specified package with makepkg
    """
    f = open_url('https://aur.archlinux.org/rpc/?v=5&type=info&arg={}'.format(package))
    result = json.loads(f.read().decode('utf8'))
    if result['resultcount'] != 1:
        return (1, '', 'package not found')
    result = result['results'][0]
    f = open_url('https://aur.archlinux.org/{}'.format(result['URLPath']))
    current_path = os.getcwd()
    with tempfile.TemporaryDirectory() as tmpdir:
        os.chdir(tmpdir)
        tar_file = '{}.tar.gz'.format(result['Name'])
        with open(tar_file, 'wb') as out:
            out.write(f.read())
        tar = tarfile.open(tar_file)
        tar.extractall()
        tar.close()
        os.chdir(format(result['Name']))
        if module.params['skip_pgp_check']:
            use_cmd['makepkg'].append('--skippgpcheck')
        rc, out, err = module.run_command(use_cmd['makepkg'], check_rc=True)
        os.chdir(current_path)
    return (rc, out, err)


def upgrade(module, use, aur_only):
    """
    Upgrade the whole system
    """
    assert use in use_cmd

    rc, out, err = module.run_command(def_lang + use_cmd[use] + ['--aur' if (aur_only and use in has_aur_option) else None] + ['-u'], check_rc=True)

    module.exit_json(
        changed=not (out == '' or 'nothing to do' in out or 'No AUR updates found' in out),
        msg='upgraded system',
        helper=use,
    )


def install_packages(module, packages, use, skip_installed, aur_only):
    """
    Install the specified packages
    """
    assert use in use_cmd

    changed_iter = False

    for package in packages:
        if skip_installed:
            if package_installed(module, package):
                rc = 0
                continue
        if use == 'makepkg':
            rc, out, err = install_with_makepkg(module, package)
        else:
            rc, out, err = module.run_command(def_lang + use_cmd[use] + ['--aur' if (aur_only and use in has_aur_option) else None] + [package], check_rc=True)

        changed_iter = changed_iter or not (out == '' or '-- skipping' in out or 'nothing to do' in out)

    if changed_iter:
        message = 'installed package(s)'
    else:
        message = 'package(s) already installed'

    module.exit_json(
        changed=changed_iter,
        msg=message if not rc else err,
        helper=use,
        rc=rc,
    )
=======
# The MIT License (MIT)
#
# Copyright (c) 2014 Austin Hyde
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import os
import pwd
import platform


def cower_in_path(module):
    """
    Determine if cower is available.
    """
    rc, stdout, stderr = module.run_command('which cower', check_rc=False)
    return rc == 0


def pacman_in_path(module):
    """
    Determine if pacman is available.
    """
    rc, stdout, stderr = module.run_command('which pacman', check_rc=False)
    return rc == 0


def package_installed(module, pkg):
    """
    Determine if a package is already installed.
    """
    rc, stdout, stderr = module.run_command('pacman -Q %s' % pkg, check_rc=False)
    return rc == 0


def check_packages(module, pkgs):
    """
    Inform the user what would change if the module were run.
    """
    would_be_changed = []

    for pkg in pkgs:
        installed = package_installed(module, pkg)
        if not installed:
            would_be_changed.append(pkg)

    if would_be_changed:
        module.exit_json(changed=True, msg='%s package(s) would be installed' % (len(would_be_changed)))
    else:
        module.exit_json(changed=False, msg='all packages are already installed')


def download_packages(module, pkgs, dir, user):
    """
    Download the specified packages.
    """
    # Use cower, if available.
    if cower_in_path(module):
        cmds = ['sudo -u %s cower -dqf %s', ]
    # Otherwise, fall back to cURL
    else:
        cmds = ['sudo -u %s curl -O https://aur.archlinux.org/cgit/aur.git/snapshot/%s.tar.gz',
                'sudo -u %s tar xzf %s.tar.gz']
    for pkg in pkgs:
        # If the package is already installed, skip the download.
        if package_installed(module, pkg):
            continue
        # Change into the specified directory for download.
        os.chdir(dir)
        # Attempt to install the package.
        for cmd in cmds:
            rc, stdout, stderr = module.run_command(cmd % (user, pkg), check_rc=False)
            if rc != 0:
                module.fail_json(msg='failed to download package %s, because: %s' % (pkg,stderr))


def install_packages(module, pkgs, dir, user, virtual):
    """
    Install the specified packages via makepkg.
    """
    num_installed = 0

    if platform.machine().startswith('arm') or platform.machine().startswith('aarch64'):
        makepkg_args = '-Acsrf'
    else:
        makepkg_args = '-csrf'
    cmd = 'sudo -u %s PKGEXT=".pkg.tar" makepkg %s --noconfirm --needed --noprogressbar' % (user, makepkg_args)
    if module.params['skip_pgp']:
        cmd += ' --skippgpcheck'
    for pkg in pkgs:
        # If the package is already installed, skip the install.
        if package_installed(module, pkg):
            continue
        
        # Change into the package directory.
        # Check if the package is a virtual package
        if virtual:
            os.chdir(os.path.join(dir, virtual))
        else:
            os.chdir(os.path.join(dir, pkg))
        
        # Attempt to build the directory.
        rc, stdout, stderr = module.run_command(cmd, check_rc=False)
        if rc != 0:
            module.fail_json(msg='failed to build package %s, because: %s' % (pkg,stderr))

        # If the package was succesfully built, install it.
        rc, stdout, stderr = module.run_command('pacman -U --noconfirm *.pkg.tar*', check_rc=False, use_unsafe_shell=True)
        if rc != 0:
            module.fail_json(msg='failed to install package %s, because: %s' % (pkg,stderr))
        else:
            num_installed += 1

    # Exit with the number of packages succesfully installed.
    if num_installed > 0:
        module.exit_json(changed=True, msg='installed %s package(s)' % num_installed)
    else:
        module.exit_json(changed=False, msg='all packages were already installed')
>>>>>>> 92940cedaebee392be067aebbb88462d1c31952e


def main():
    module = AnsibleModule(
<<<<<<< HEAD
        argument_spec={
            'name': {
                'type': 'list',
            },
            'upgrade': {
                'default': False,
                'type': 'bool',
            },
            'use': {
                'default': 'auto',
                'choices': ['auto', 'aurman', 'pacaur', 'trizen', 'pikaur', 'yaourt', 'yay', 'makepkg'],
            },
            'skip_installed': {
                'default': False,
                'type': 'bool',
            },
            'skip_pgp_check': {
                'default': False,
                'type': 'bool',
            },
            'aur_only': {
                'default': False,
                'type': 'bool',
            },
        },
        required_one_of=[['name', 'upgrade']],
        supports_check_mode=True
    )

    params = module.params

    if module.check_mode:
        check_packages(module, params['name'])

    if params['use'] == 'auto':
        use = 'makepkg'
        # auto: select the first helper for which the bin is found
        for k in use_cmd:
            if module.get_bin_path(k, False):
                use = k
                break
    else:
        use = params['use']

    if params['upgrade'] and (params['name'] or params['skip_installed'] or use == 'makepkg'):
        module.fail_json(msg="Upgrade cannot be used with this option.")
    else:
        if params['upgrade']:
            upgrade(module, use, params['aur_only'])
        else:
            install_packages(module, params['name'], use, params['skip_installed'], params['aur_only'])


if __name__ == '__main__':
    main()
=======
        argument_spec = dict(
            name = dict(required=True),
            user = dict(required=True),
            dir  = dict(),
            skip_pgp = dict(default=False, type='bool'),
            virtual = dict(),
        ),
        supports_check_mode = True
    )

    # Fail of pacman is not available.
    if not pacman_in_path(module):
        module.fail_json(msg="could not locate pacman executable")

    p = module.params

    # Get all the requested package names.
    pkgs = p['name'].split(',')

    # Fail if the specified user does not exist.
    try:
        pwd.getpwnam(p['user'])
    except KeyError:
        module.fail_json(msg="user %s does not exist" % p['user'])
    else:
        user = p['user']

    # If no directory was given, assume the packages should be downloaded to
    # ~user/aur.
    if not p['dir']:
        home = os.path.expanduser('~%s' % user)
        if not os.path.exists(home):
            module.fail_json(msg="%s's home directory %s does not exist" % (user, home))

        dir = os.path.join(home, 'aur')
        if not os.path.exists(dir):
            os.makedirs(dir)
            uid = pwd.getpwnam(user).pw_uid
            os.chown(dir, uid, -1)
    else:
        dir = os.path.expanduser(p['dir'])

    # Fail if the specified directory does not exist.
    if not os.path.exists(dir):
        module.fail_json(msg="directory %s does not exist" % dir)

    if module.check_mode:
        check_packages(module, pkgs)

    download_packages(module, pkgs, dir, user)
    # Check if the package is virtual
    if p['virtual']:
        virtual = p['virtual']
    else:
        virtual = False

    install_packages(module, pkgs, dir, user, virtual)


from ansible.module_utils.basic import *
main()
>>>>>>> 92940cedaebee392be067aebbb88462d1c31952e
